#!/bin/bash

readonly program="$(basename "$0")"
readonly submit_pr_to='caskroom:master'
remote_pull='upstream' # use 'upstream' as default remote to pull from
remote_push='origin' # use 'origin' as default remote to push to

# check if 'hub' is installed and configured
if [[ ! $(which 'hub') ]]; then
  echo -e "$(tput setaf 1)
    This script requires 'hub'.
    If you have [Homebrew](http://brew.sh), you can install it with 'brew install hub'.
    If it isn’t yet, it will ask to be configured at the appropriate step.
  $(tput sgr0)" | sed -E 's/ {4}//' >&2
  exit 1
fi

syntax_error() {
  echo "$program: $1" >&2
  echo "Try \`$program --help\` for more information." >&2
  exit 1
}

usage() {
  echo "
    usage: $program [options] <cask_name>

    options:
      -l <remote>, --pull <remote>   Use to specify a remote to pull from (defaults to 'upstream').
      -p <remote>, --push <remote>   Use to specify a remote to push to (defaults to 'origin').
      -h, --help                     Show this help.
  " | sed -E 's/^ {4}//'
}

# available flags
while [[ "$1" ]]; do
  case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    -l | --pull)
      remote_pull="$2"
      shift
      ;;
    -p | --push)
      remote_push="$2"
      shift
      ;;
    -*)
      syntax_error "unrecognized option: $1"
      ;;
    *)
      break
      ;;
  esac
  shift
done

# define function to get HTTP status codes of URLs
http_status() {
  local url="$1"
  [[ "$2" == 'follow_redirects' ]] && local follow_redirects='--location' || local follow_redirects='--no-location'
  local browser_headers='User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36'

  curl --silent --head "${follow_redirects}" --header "${browser_headers}" "${url}" | grep '^HTTP' | tail -1 | perl -pe 's|.* (\d{3}) .*|\1|'
}

# define function to modify stanzas
modify_stanza() {
  stanza_to_modify="$1"
  new_stanza_value="$2"

  perl -0777 -i -e'
    $stanza_to_modify = shift(@ARGV);
    $new_stanza_value = shift(@ARGV);
    print <> =~ s|\A.*^\s*\Q$stanza_to_modify\E\s\K[^\n]*|$new_stanza_value|smr;
  ' "${stanza_to_modify}" "${new_stanza_value}" "${cask_file}"
}

# define function to check and modify sha256
sha_change() {
  local cask_sha_deliberatedly_unchecked=$(grep 'sha256 :no_check # required as upstream package is updated in-place' "${cask_file}")
  [[ -n "${cask_sha_deliberatedly_unchecked}" ]] && return # abort function if cask deliberate uses ':no_check' with a version

  # set sha256 as :no_check tempoparily, to prevent mismatch errors when fetching
  modify_stanza 'sha256' ':no_check'

  brew cask fetch --force "${cask_file}"
  local downloaded_file=$(brew cask fetch "${cask_file}" 2>/dev/null | tail -1 | sed 's/==> Success! Downloaded to -> //')
  local package_sha=$(shasum --algorithm 256 "${downloaded_file}" | awk '{ print $1 }')

  modify_stanza 'sha256' "'${package_sha}'"
}

# define function to check and modify appcast's sha256
appcast_sha_change() {
  local cask_appcast_url=$(brew cask _stanza appcast "${cask_file}")
  [[ -z "${cask_appcast_url}" ]] && return # abort function if cask does not have an appcast

  local cask_appcast_sha=$(curl --silent "${cask_appcast_url}" | shasum --algorithm 256 | awk '{ print $1 }')
  local cask_appcast_status=$(http_status "${cask_appcast_url}" 'no_follow_redirects')

  # set appcast's sha256 to empty, if its url returns an empty string
  if [[ "${cask_appcast_sha}" == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855' ]]; then
    cask_appcast_sha='appcast is probably incorrect, as an empty string was returned'
  elif [[ "${cask_appcast_status}" != '200' ]]; then
    cask_appcast_sha="appcast is probbly incorrect, as non-200 (OK) HTTP response code was returned (${cask_appcast_status})"
  fi

  modify_stanza ':sha256 =>' "'${cask_appcast_sha}'"
}

# define function to quickly call both sha changing functions
update_cask_shas() {
  sha_change
  appcast_sha_change
}

# define abort function, that will reset the state
finish() {
  git reset HEAD --hard --quiet
  git checkout master --quiet
  git branch -D "${cask_branch}" --quiet

  # show message
  if [[ "$1" == 'abort' ]]; then
    echo -e "\n$(tput setaf 1)$2$(tput sgr0)\n"
    exit 1
  elif [[ "$1" == 'success' ]]; then
    echo -e "\n$(tput setaf 2)Submitted$(tput sgr0)\n"
    exit 0
  fi
}

# cleanup if aborted with ⌃C
trap 'finish abort "You aborted"' SIGINT

# define divider function
divide() {
  if [[ $(which hr) ]]; then
    hr -
  else
    echo '--------------------'
  fi
}

# exit if not inside a 'homebrew-*/Casks' directory
casks_dir=$(pwd | perl -ne 'print m{homebrew-[^/]+/Casks}')
if [[ -z "${casks_dir}" ]]; then
  echo -e "\n$(tput setaf 1)You need to be inside a '/homebrew-*/Casks' directory$(tput sgr0)\n"
  exit 1
fi

# exit if no argument was given
if [[ -z "$1" ]]; then
  usage
  exit 1
fi

# clean the cask's name, and check if it is valid
cask_name="$1"
[[ "${cask_name}" == *'.rb' ]] && cask_name=$(echo "${cask_name}" | sed 's|\.rb$||')
cask_file="./${cask_name}.rb"
cask_branch="update-${cask_name}"
[[ ! -f "${cask_file}" ]] && finish abort 'There is no such cask'

# initial tasks
git checkout master --quiet
git pull --rebase "${remote_pull}" master --quiet
git checkout -b "${cask_branch}" --quiet

# show cask's current state
divide
brew cask home "${cask_file}"
cat "${cask_file}"
divide

# check if cask's url is always up to date
cask_old_url=$(grep "url ['\"].*['\"]" "${cask_file}" | sed -E "s|.*url ['\"](.*)['\"].*|\1|")
[[ "${cask_old_url}" =~ \#{version.*} ]] && cask_url_up_to_date='true'

# if url is always up to date, use it; else ask for it to be in the clipboard
if [[ "${cask_url_up_to_date}" ]]; then
  read -p 'Type the new version (or leave blank to abort)
> ' given_cask_version
else
  read -p 'Save the new download URL to your clipboard, and type the new version (or leave blank to abort)
> ' given_cask_version
  cask_url="$(pbpaste)"

  [[ -z "${given_cask_version}" ]] && finish abort 'You decided to abort' # abort if no version was given
  [[ "${given_cask_version}" == 'latest' ]] && given_cask_version=':latest' # allow both ':latest' and 'latest' to be given

  # check if the URL sends a 200 HTTP code, else abort
  cask_status=$(http_status "${cask_url}" 'follow_redirects')

  # if the download URL is from github or bitbucket, fake the status code
  [[ "${cask_url}" =~ (github.com|bitbucket.org) ]] && cask_status='200'

  if [[ "${cask_status}" != '200' ]]; then
    if [[ -z "${cask_status}" ]]; then
      finish abort 'You need to have a valid URL in your clipboard'
    else
      finish abort "Download URL returned ${cask_status}"
    fi
  fi

  # modify url
  modify_stanza 'url' "'${cask_url}'"
fi

# change version and sha256, and calculate new sha256 values as appropriate if not using :latest version
if [[ "${given_cask_version}" =~ ^:latest$ ]]; then
  modify_stanza 'version' ':latest'
  modify_stanza 'sha256' ':no_check'
else
  modify_stanza 'version' "'${given_cask_version}'"
  update_cask_shas
fi

# check if everything is alright, else abort
cask_updated='false'
until [[ "${cask_updated}" =~ ^[yne]$ ]]; do
  # audit cask
  brew cask audit "${cask_file}"

  git diff
  divide

  read -n1 -p 'Is everything correct? You can also make further manual edits (y/n/e) ' cask_updated

  if [[ "${cask_updated}" == 'y' ]]; then
    break
  elif [[ "${cask_updated}" == 'e' ]]; then
    open -W "${cask_file}"
    [[ "$(brew cask _stanza version ${cask_file})" != 'latest' ]] && update_cask_shas # recheck sha256 values if version isn't :latest
    cask_updated='false'
  elif [[ "${cask_updated}" == 'n' ]]; then
    finish abort 'You decided to abort'
  fi
done

# grab version as it ended up in the cask
final_cask_version="$(brew cask _stanza version ${cask_file})"

# commit, push, submit pull request, clean
readonly commit_message="updated ${cask_name} (${final_cask_version})"

git commit "${cask_file}" --message "${commit_message}" --quiet
git push "${remote_push}" "${cask_branch}" --quiet
hub pull-request -b "${submit_pr_to}" -m "${commit_message}"
finish success
