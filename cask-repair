#!/bin/bash

readonly program="$(basename "$0")"
readonly submit_pr_to='caskroom:master'
remote_pull='upstream' # use 'upstream' as default remote to pull from
remote_push='origin' # use 'origin' as default remote to push to
open_home='true' # by default, open the cask's homepage

# check if 'hub' is installed and configured
if [[ ! $(which 'hub') ]] || [[ ! $(grep 'oauth_token:' "${HOME}/.config/hub" 2>/dev/null) ]]; then
  echo -e "$(tput setaf 1)
    This script requires 'hub' installed and configured.
    If you have [Homebrew](http://brew.sh), you can install it with 'brew install hub'.
    To configure it, run 'cd $(brew --repository) && hub issue'. Your Github password will be required, but is never stored.
  $(tput sgr0)" | sed -E 's/ {4}//' >&2
  exit 1
fi

syntax_error() {
  echo "$program: $1" >&2
  echo "Try \`$program --help\` for more information." >&2
  exit 1
}

usage() {
  echo "
    usage: $program [options] <cask_name>

    options:
      -l <remote>, --pull <remote>   Use to specify a remote to pull from (defaults to 'upstream').
      -p <remote>, --push <remote>   Use to specify a remote to push to (defaults to 'origin').
      -n, --no-home                  Do not open the homepage for the given cask.
      -v, --cask-version             Give a version directly, instead of being prompted for it.
      -u, --cask-url                 Give a URL directly, instead of being prompted for it.
      -h, --help                     Show this help.
  " | sed -E 's/^ {4}//'
}

# available flags
while [[ "$1" ]]; do
  case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    -l | --pull)
      remote_pull="$2"
      shift
      ;;
    -p | --push)
      remote_push="$2"
      shift
      ;;
    -n | --no-home)
      open_home='false'
      ;;
    -v | --cask-version)
      given_cask_version="$2"
      shift
      ;;
    -u | --cask-url)
      given_cask_url="$2"
      shift
      ;;
    -*)
      syntax_error "unrecognized option: $1"
      ;;
    *)
      break
      ;;
  esac
  shift
done

# define function to get HTTP status codes of URLs
http_status() {
  local url="$1"
  [[ "$2" == 'follow_redirects' ]] && local follow_redirects='--location' || local follow_redirects='--no-location'
  local browser_headers=(--header 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36')

  curl --silent --head "${follow_redirects}" "${browser_headers[@]}" --write-out '%{http_code}' "${url}" -o '/dev/null'
}

# define function to check if a given string contains ruby-style interpolation
has_interpolation() {
  [[ "$1" =~ \#{version.*} ]] && echo 'true' || echo 'false'
}

# define function to check if cask is using :latest version
is_version_latest() {
  [[ "$(brew cask _stanza version ${cask_file})" == 'latest' ]] && echo 'true' || echo 'false'
}

# define function to modify stanzas
modify_stanza() {
  stanza_to_modify="$1"
  new_stanza_value="$2"

  perl -0777 -i -e'
    $stanza_to_modify = shift(@ARGV);
    $new_stanza_value = shift(@ARGV);
    print <> =~ s|\A.*^\s*\Q$stanza_to_modify\E\s\K[^\n]*|$new_stanza_value|smr;
  ' "${stanza_to_modify}" "${new_stanza_value}" "${cask_file}"
}

# define function to check and modify sha256
sha_change() {
  local cask_sha_deliberatedly_unchecked=$(grep 'sha256 :no_check # required as upstream package is updated in-place' "${cask_file}")
  [[ -n "${cask_sha_deliberatedly_unchecked}" ]] && return # abort function if cask deliberate uses ':no_check' with a version

  # set sha256 as :no_check tempoparily, to prevent mismatch errors when fetching
  modify_stanza 'sha256' ':no_check'

  brew cask fetch --force "${cask_file}"
  local downloaded_file=$(brew cask fetch "${cask_file}" 2>/dev/null | tail -1 | sed 's/==> Success! Downloaded to -> //')
  local package_sha=$(shasum --algorithm 256 "${downloaded_file}" | awk '{ print $1 }')

  modify_stanza 'sha256' "'${package_sha}'"
}

# define function to check and modify appcast's checkpoint sha256
appcast_checkpoint_change() {
  local cask_appcast_url=$(brew cask _stanza appcast "${cask_file}")
  [[ -z "${cask_appcast_url}" ]] && return # abort function if cask does not have an appcast

  local cask_appcast_checkpoint=$(curl --silent --compressed "${cask_appcast_url}" | sed 's|<pubDate>[^<]*</pubDate>||g' | shasum --algorithm 256 | awk '{ print $1 }')
  local cask_appcast_status=$(http_status "${cask_appcast_url}" 'no_follow_redirects')

  if [[ "${cask_appcast_checkpoint}" == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855' ]]; then
    cask_appcast_checkpoint='appcast is probably incorrect, as an empty string was returned'
  elif [[ "${cask_appcast_status}" != '200' ]]; then
    cask_appcast_checkpoint="appcast is probably incorrect, as a non-200 (OK) HTTP response code was returned (${cask_appcast_status})"
  fi

  modify_stanza ':checkpoint =>' "'${cask_appcast_checkpoint}'"
}

# define function to quickly call both sha changing functions
update_cask_shas() {
  sha_change
  appcast_checkpoint_change
}

# define abort function, that will reset the state
finish() {
  git reset HEAD --hard --quiet
  git checkout master --quiet
  git branch -D "${cask_branch}" --quiet

  # show message
  if [[ "$1" == 'abort' ]]; then
    echo -e "\n$(tput setaf 1)$2$(tput sgr0)\n"
    exit 1
  elif [[ "$1" == 'success' ]]; then
    echo -e "\n\n$(tput setaf 2)Submitted ($2)$(tput sgr0)\n"
    exit 0
  fi
}

# cleanup if aborted with âŒƒC
trap 'finish abort "You aborted"' SIGINT

# define divider function
divide() {
  if [[ $(which hr) ]]; then
    hr -
  else
    echo '--------------------'
  fi
}

# exit if not inside a 'homebrew-*/Casks' directory
casks_dir=$(pwd | perl -ne 'print m{homebrew-[^/]+/Casks}')
if [[ -z "${casks_dir}" ]]; then
  echo -e "\n$(tput setaf 1)You need to be inside a '/homebrew-*/Casks' directory$(tput sgr0)\n"
  exit 1
fi

# exit if no argument or more than one argument was given
if [[ -z "$1" ]]; then
  usage
  exit 1
fi

[[ -n "$2" ]] && 'finish abort "You can only give one cask argument per run"'

# clean the cask's name, and check if it is valid
cask_name="$1"
[[ "${cask_name}" == *'.rb' ]] && cask_name=$(echo "${cask_name}" | sed 's|\.rb$||')
cask_file="./${cask_name}.rb"
cask_branch="update-${cask_name}"
[[ ! -f "${cask_file}" ]] && finish abort 'There is no such cask'

# initial tasks
git checkout master --quiet
git pull --rebase "${remote_pull}" master --quiet
git checkout -b "${cask_branch}" --quiet

# show cask's current state
divide
[[ "${open_home}" == 'true' ]] && brew cask home "${cask_file}"
cat "${cask_file}"
divide

# set cask version
if [[ -z "${given_cask_version}" ]]; then
  read -p $'Type the new version (or leave blank to abort)\n> ' given_cask_version # ask for cask version, if not given previously

  [[ -z "${given_cask_version}" ]] && finish abort 'You decided to abort' # abort if no version was given
fi

if [[ "${given_cask_version}" == ':latest' ]] || [[ "${given_cask_version}" == 'latest' ]]; then # allow both ':latest' and 'latest' to be given
  modify_stanza 'version' ':latest'
else
  modify_stanza 'version' "'${given_cask_version}'"
fi

# check if cask's url uses interpolation
cask_bare_url=$(grep "url ['\"].*['\"]" "${cask_file}" | sed -E "s|.*url ['\"](.*)['\"].*|\1|")
[[ $(has_interpolation "${cask_bare_url}") == 'true' ]] && cask_url_uses_interpolation='true' || cask_url_uses_interpolation='false'

# if url does not use interpolation, ask for it
if [[ "${cask_url_uses_interpolation}" == 'false' ]]; then
  if [[ -z "${given_cask_url}" ]]; then
    read -p $'Paste the new URL (or leave blank to use the current one)\n> ' given_cask_url

    [[ -z "${given_cask_url}" ]] && given_cask_url=$(brew cask _stanza url "${cask_file}")
  fi

  [[ $(has_interpolation "${given_cask_url}") == 'true' ]] && modify_stanza 'url' "\"${given_cask_url}\"" || modify_stanza 'url' "'${given_cask_url}'" # use appropriate quotes depending on if a url with interpolation was given
  cask_url=$(brew cask _stanza url "${cask_file}")

  # check if the URL sends a 200 HTTP code, else abort
  cask_url_status=$(http_status "${cask_url}" 'follow_redirects')

  [[ "${cask_url}" =~ (github.com|bitbucket.org) ]] && cask_url_status='200' # if the download URL is from github or bitbucket, fake the status code

  if [[ "${cask_url_status}" != '200' ]]; then
    if [[ -z "${cask_url_status}" ]]; then
      finish abort 'You need to paste a valid URL'
    else
      finish abort "Download URL returned ${cask_url_status}"
    fi
  fi
fi

[[ "$(is_version_latest)" == 'false' ]] && update_cask_shas || modify_stanza 'sha256' ':no_check' # calculate new sha256 values

# check if everything is alright, else abort
cask_updated='false'
until [[ "${cask_updated}" =~ ^[yne]$ ]]; do
  # fix style errors and audit cask
  brew cask style --fix "${cask_file}"
  brew cask audit "${cask_file}"
  brew cask style --fix "${cask_file}"

  git diff
  divide

  read -n1 -p 'Is everything correct? You can also make further manual edits (y/n/e) ' cask_updated

  if [[ "${cask_updated}" == 'y' ]]; then
    break
  elif [[ "${cask_updated}" == 'e' ]]; then
    open -W "${cask_file}"
    [[ "$(is_version_latest)" == 'false' ]] && update_cask_shas # recheck sha256 values if version isn't :latest
    cask_updated='false'
  elif [[ "${cask_updated}" == 'n' ]]; then
    finish abort 'You decided to abort'
  fi
done

# grab version as it ended up in the cask
cask_version="$(brew cask _stanza version ${cask_file})"

# commit, push, submit pull request, clean
readonly commit_message="updated ${cask_name} (${cask_version})"

git commit "${cask_file}" --message "${commit_message}" --quiet
git push "${remote_push}" "${cask_branch}" --quiet
pr_link=$(hub pull-request -b "${submit_pr_to}" -m "${commit_message}")
finish success "${pr_link}"
